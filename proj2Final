/*  EA076C
    Módulo 1: Leitura e escrita na memória EEPROM 24C16

    Alunos:
        Deivit Lopes Bonach     RA:166508
        Vinicius Henrique Luiz  RA:245342
*/

#include <Wire.h>
#define EEPROM_ADDR 0x50 // Endereço da memória EEPROM 24C16
#include <Arduino.h>
#include <LiquidCrystal.h>

// definicao de constantes
#define ROWS 4
#define COLS 3
#define NO_ACTIVE_LINE 100
#define TRUE 1
#define FALSE 0

// arrays que mapeiam os pinos do arduino para as linhas e colunas do teclado
const char rowPins[ROWS] = {2, 3, 4, 5};
const char colPins[COLS] = {6, 7, 8};

// mapeamento do teclado para obtencao das teclas acionadas
char keypad[ROWS][COLS] = {
  {'1', '2', '3'},
  {'4', '5', '6'},
  {'7', '8', '9'},
  {'*', '0', '#'}
};

// configuracao display LCD
int RS = 19;
int E = 18;
int D4 = 17;
int D5 = 16;
int D6 = 15;
int D7 = 14;

LiquidCrystal lcd(RS, E, D4, D5, D6, D7);

// declaracao de variaveis globais
char activeColumn = 0;
char currentLine = NO_ACTIVE_LINE;
char previousLine = NO_ACTIVE_LINE;
char debouncedLine = NO_ACTIVE_LINE;

// configuracao do timer1 para gerar uma interrupcao a cada 50ms
void configuracao_Timer1(){
    
    // configura timer1 para operar no modo CTC (Clear Timer on Compare Match)
    TCCR1A = 0;
    TCCR1B = 0;
    TCCR1B |= (1 << WGM12);
    
    // valor de comparacao que corresponde a 50ms considerando o prescaler de 1024 e clock de 16MHz
    OCR1A = 781;
    
    // ativa interrupcao por comparacao com o registrador OCR1A
    TIMSK1 |= (1 << OCIE1A);
    
    // configura o prescaler para 1024
    TCCR1B |= (1 << CS12) | (1 << CS10);
}
/* Configuracao da comunicacao serial. */
void setup(void)  {
  Serial.begin(9600); // Set baud rate
  Wire.begin(); // Join I2C bus
}

/* Escrita de um byte na memoria */
void escrever(unsigned int add, unsigned char dado){

  /* Desloca 8 bits a direita para separar os 3 bits mais significativos do endereço */
  unsigned int byteMstAdd = add>>8;

  /* byte menos significativo do endereço da memoria */
  unsigned char byteLstAdd = (unsigned char)add;

  /* Atribuição de uma mascara para juntar os bits do endereço da 
  EEPROM com os 3 primeiros bits do endereço do dado */  
  int primeiroByteTransmitido = (EEPROM_ADDR |byteMstAdd);
  
  /* Processo de escrita do byte dado na EEPROM no endereço add */
  Wire.beginTransmission(primeiroByteTransmitido);
  Wire.write(byteLstAdd); 
  Wire.write(dado); 
  Wire.endTransmission();
}

unsigned char ler(unsigned int add){
  
  /* Desloca 8 bits a direita para separar os 3 bits mais significativos do endereço */  
  unsigned int byteMstAdd = add >> 8;

  /* byte menos significativo do endereço da memoria */
  unsigned int byteLstAdd = (unsigned char) add;

  /* Atribuição de uma mascara para juntar os bits do endereço da 
  EEPROM com os 3 primeiros bits do endereço do dado */
  int primeiroByteTransmitido = (EEPROM_ADDR | byteMstAdd); 

  /* Escrita com o objetivo de escolher o endereço a ser lido */
  Wire.beginTransmission(primeiroByteTransmitido); // Inicia a transmissão para o endereço da memória
  Wire.write(byteLstAdd); // Escreve o byte restante de endereço de memoria
  Wire.endTransmission(); // Executa a transmissão
  Wire.requestFrom(primeiroByteTransmitido, 1); // Solicita 1 byte de dados da memória

  byte data = Wire.read();
  
  return data;
}

void loop(){
  escrever(0x20F, 0xF3);
  delay(5);
  ler(0x20F);
  
  /* Delay com objetivo de segurar o loop e analisar apenas a primeira iteracao */
  delay(10000000);
}
